use crate::error::Result;
use crate::reporting::BrandingInfo;
use serde::Deserialize;
use std::path::PathBuf;

#[derive(Deserialize, Debug, Clone)]
pub struct BrandingConfig {
    pub company_name: Option<String>,
    pub logo_path: Option<PathBuf>,
    pub primary_color: Option<String>,
    pub secondary_color: Option<String>,
    pub css_overrides: Option<String>,
    pub custom_css_file: Option<PathBuf>,
    pub report_footer: Option<String>,
}

impl BrandingConfig {
    pub fn from_file(path: &PathBuf) -> Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let config: BrandingConfig = serde_json::from_str(&content)?;
        Ok(config)
    }

    pub fn to_branding_info(&self) -> BrandingInfo {
        BrandingInfo {
            company_name: self.company_name.clone(),
            logo_path: self
                .logo_path
                .as_ref()
                .map(|p| p.to_string_lossy().to_string()),
            primary_color: self.primary_color.clone(),
            secondary_color: self.secondary_color.clone(),
            css_overrides: self.load_css_overrides(),
        }
    }

    fn load_css_overrides(&self) -> Option<String> {
        // Priority: direct css_overrides, then css_file
        if let Some(css) = &self.css_overrides {
            return Some(css.clone());
        }

        if let Some(css_file) = &self.custom_css_file {
            if let Ok(content) = std::fs::read_to_string(css_file) {
                return Some(content);
            }
        }

        None
    }

    pub fn validate(&self) -> Result<()> {
        // Validate color formats if provided
        if let Some(color) = &self.primary_color {
            if !color.is_empty() && !Self::is_valid_color_format(color) {
                return Err(crate::error::Error::config("Invalid primary color format"));
            }
        }

        if let Some(color) = &self.secondary_color {
            if !color.is_empty() && !Self::is_valid_color_format(color) {
                return Err(crate::error::Error::config(
                    "Invalid secondary color format",
                ));
            }
        }

        // Validate file paths if provided
        if let Some(logo_path) = &self.logo_path {
            if !logo_path.exists() {
                return Err(crate::error::Error::config("Logo file does not exist"));
            }
        }

        if let Some(css_file) = &self.custom_css_file {
            if !css_file.exists() {
                return Err(crate::error::Error::config("CSS file does not exist"));
            }
        }

        Ok(())
    }

    /// Validate color format (hex codes like #ffffff or ffffff, or named colors)
    fn is_valid_color_format(color: &str) -> bool {
        // Handle hex colors with or without #
        let hex_part = color.strip_prefix('#').unwrap_or(color);

        // Valid hex color: 3 or 6 hex characters
        if hex_part.len() == 3 || hex_part.len() == 6 {
            return hex_part.chars().all(|c| c.is_ascii_hexdigit());
        }

        // Also allow common named colors
        matches!(
            color.to_lowercase().as_str(),
            "red"
                | "green"
                | "blue"
                | "black"
                | "white"
                | "gray"
                | "grey"
                | "yellow"
                | "orange"
                | "purple"
                | "pink"
                | "brown"
                | "cyan"
                | "magenta"
        )
    }
}

impl Default for BrandingConfig {
    fn default() -> Self {
        BrandingConfig {
            company_name: None,
            logo_path: None,
            primary_color: Some("#2563eb".to_string()), // Blue-600
            secondary_color: Some("#64748b".to_string()), // Slate-500
            css_overrides: None,
            custom_css_file: None,
            report_footer: Some("Generated by Mandrel MCP Test Harness".to_string()),
        }
    }
}
